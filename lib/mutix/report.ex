defmodule Mutix.Report do
  @moduledoc false

  @typep exunit_test_result :: %{
           total: non_neg_integer(),
           failures: non_neg_integer(),
           excluded: non_neg_integer(),
           skipped: non_neg_integer()
         }

  @typep mutation_test_result ::
           {result :: exunit_test_result(), meta :: Keyword.t(), io_output :: String.t()}

  @spec mutation(list(mutation_test_result()), {String.t(), String.t()}, {atom(), atom()}) ::
          String.t()
  def mutation(test_results, {source_file_path, source_content}, operator_mutation) do
    {from, to} = operator_mutation
    score = mutation_score(test_results)

    percentage = (score.mutant_count - score.survived_count) / score.mutant_count * 100
    percentage = Float.round(percentage, 1)

    percentage =
      if percentage > 50,
        do: color(percentage, [:green, :bright]),
        else: color(percentage, [:red, :bright])

    survived = score.survived

    survived_report =
      if Enum.count(survived) > 0,
        do: survived_report(survived, {source_file_path, source_content}, operator_mutation),
        else: nil

    """
    #{color("Results:", [:cyan, :bright])}

        #{color(score.mutant_count, [:blue, :bright])} mutants were generated by mutating ( #{color(from, :green)} ) into ( #{color(to, :red)} ).

        #{color(score.test_count, [:blue, :bright])} tests were run for each mutant.

        #{color(score.killed_count, :green)} / #{color(score.mutant_count, [:blue, :bright])} mutants killed by the test suite.

        Mutation score: #{percentage} %
    #{survived_report}
    """
  end

  # Internal

  defp mutation_score(test_results) do
    survived = Enum.filter(test_results, fn {%{failures: failures}, _, _} -> failures == 0 end)
    exunit_results = Enum.map(test_results, fn {result, _, _} -> result end)

    mutant_count = Enum.count(exunit_results)
    survived_count = Enum.count(survived)
    killed = mutant_count - survived_count

    total = exunit_results |> List.first() |> Map.fetch!(:total)

    %{
      mutant_count: mutant_count,
      killed_count: killed,
      survived_count: survived_count,
      survived: survived,
      test_count: total
    }
  end

  defp survived_report(survived, {source_file_path, source_content}, {from, to}) do
    lines = String.split(source_content, "\n")

    surviving =
      for {_, meta, _} <- survived do
        line = Keyword.fetch!(meta, :line)
        index = Keyword.fetch!(meta, :index_on_line)

        context =
          [
            Enum.at(lines, line - 2),
            Enum.at(lines, line - 1),
            Enum.at(lines, line)
          ]
          |> trim_context()
          |> Enum.map(&String.pad_leading(&1, String.length(&1) + 8))
          # TODO: color only the operator here, not the entire line
          |> List.update_at(1, fn line -> color(line, :red) end)
          |> Enum.join("\n")

        if index == 0 do
          """
          #{color(source_file_path, :magenta)}:#{color(line, :magenta)} where ( #{color(from, :green)} ) was mutated into ( #{color(to, :red)} ):

          #{context}
          """
        else
          """
          #{source_file_path} - line #{line} where the #{index + 1}. ( #{color(from, :green)} ) from left was mutated into ( #{color(to, :red)} )

          #{context}
          """
        end
      end

    """

    #{color("Surviving mutants", [:magenta, :bright])} - no test failed with these injections:

        #{Enum.join(surviving, "\n    ")}
    """
  end

  defp color(value, ansi), do: IO.ANSI.format([ansi | to_string(value)])

  defp trim_context(lines) do
    trimmed_lines = Enum.map(lines, &String.trim/1)

    min_whitespace =
      lines
      |> Enum.zip_with(trimmed_lines, fn line, trimmed ->
        String.length(line) - String.length(trimmed)
      end)
      |> Enum.min()

    Enum.map(lines, fn line -> String.slice(line, min_whitespace..-1) end)
  end
end
