defmodule Mutix.Report do
  @moduledoc false

  @typep exunit_test_result :: %{
           total: non_neg_integer(),
           failures: non_neg_integer(),
           excluded: non_neg_integer(),
           skipped: non_neg_integer()
         }

  @typep mutation_test_result ::
           {result :: exunit_test_result(), meta :: Keyword.t(), io_output :: String.t()}

  @spec mutation(list(mutation_test_result()), {String.t(), String.t()}, {atom(), atom()}) ::
          String.t()
  def mutation(test_results, {source_file_path, source_content}, operator_mutation) do
    {from, to} = operator_mutation
    score = mutation_score(test_results)

    percentage = (score.mutant_count - score.survived_count) / score.mutant_count * 100
    percentage = Float.round(percentage, 1)

    percentage =
      if percentage > 50,
        do: color(percentage, [:green, :bright]),
        else: color(percentage, [:red, :bright])

    survived = score.survived

    survived_report =
      if Enum.count(survived) > 0,
        do: survived_report(survived, {source_file_path, source_content}, operator_mutation),
        else: nil

    """
    #{color("Results:", [:cyan, :bright])}

        #{score.mutant_count} mutants were generated by mutating ( #{color(from, :green)} ) into ( #{color(to, :red)} ).

        #{score.test_count} tests were run for each mutant.

        #{score.killed_count} / #{score.mutant_count} mutants killed by the test suite.

        Mutation score: #{percentage} %
    #{survived_report}
    """
  end

  # Internal

  defp mutation_score(test_results) do
    survived = Enum.filter(test_results, fn {%{failures: failures}, _, _} -> failures == 0 end)
    exunit_results = Enum.map(test_results, fn {result, _, _} -> result end)

    mutant_count = Enum.count(exunit_results)
    survived_count = Enum.count(survived)
    killed = mutant_count - survived_count

    total = exunit_results |> List.first() |> Map.fetch!(:total)

    %{
      mutant_count: mutant_count,
      killed_count: killed,
      survived_count: survived_count,
      survived: survived,
      test_count: total
    }
  end

  defp survived_report(survived, {source_file_path, source_content}, {from, to}) do
    lines = to_lines(source_content) |> Enum.map(fn {l, s} -> s end)

    # print_test(source_content)

    surviving =
      for {_, meta, _} <- survived do
        line = Keyword.fetch!(meta, :line)
        index = Keyword.fetch!(meta, :index_on_line)

        # TODO: trim all according to the least indented.
        context =
          [
            Enum.at(lines, line - 2),
            # TODO: find and color the operator here
            Enum.at(lines, line - 1),
            Enum.at(lines, line)
          ]
          |> trim_context()
          |> Enum.join("\n")
          |> IO.inspect(label: "trimmed context")

        if index == 0 do
          """
          #{IO.ANSI.format([:magenta, source_file_path])}:#{color(line, :magenta)} where ( #{color(from, :green)} ) was mutated into ( #{color(to, :red)} ):
          #{context}
          """
        else
          "#{source_file_path} - line #{line} where the #{index + 1}. ( #{from} ) from left was mutated into ( #{to} )"
        end
      end

    """

    #{IO.ANSI.format([:magenta, :bright, "Surviving mutants"])} - no test failed with these injections:

        #{Enum.join(surviving, "\n    ")}
    """
  end

  defp to_lines(source) when is_binary(source) do
    source
    |> String.split("\n")
    |> Enum.with_index(1)
    |> Enum.map(fn {line, i} -> {i, line} end)
  end

  defp line_at(lines, line_number) when is_list(lines) do
    # Enum.at(lines, )
  end

  defp color(value, ansi), do: IO.ANSI.format([ansi | to_string(value)])

  defp trim_context(lines) do
    trimmed_lines = Enum.map(lines, &String.trim/1)

    min_whitespace =
      lines
      |> Enum.zip_with(trimmed_lines, fn line, trimmed ->
        trimmed_char_count = String.length(line) - String.length(trimmed)
      end)
      |> Enum.min()

    Enum.map(lines, fn line -> String.slice(line, min_whitespace..-1) end)
  end
end
